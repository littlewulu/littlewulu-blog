---
title: "RabbitMQ【二】消息属性概述"
date: 2020-02-04T11:49:44+08:00
---


# 消息属性

* 消息属性是一组预定义的值，包含在`消息头帧`中，这些值通过`Basic.Properties`数据结构进行指定；
    * 其中某些属性（例如 delivery-mode）在AMQP协议中有明确的含义，有些属性（例如 type）则没有明确的规范；

* 先来个图
    * ![1-1.jpg](https://littlewulu.cn/source/images/2002/04_QqX8mvJIQYbdI12Um0h6nyzfKr7rUG.jpg)

# 消息属性概述

* 在消息标准化的发展过程中，AMQP消息属性为定义和传输消息元数据提供了一个有用的起点
* `content-type` : 让消费者知道如何解释消息体
    * 当消息的有效载荷格式无法自描述时，你的应用程序会倾向使用一种隐式契约，这种隐式契约天生容易出错
    * 显式指定content-type是明智的，如使用 application/json，这让消费者可以明确地知道如何反序列化消息体
* `content-encoding` : 指示消息体使用某种特殊的方式进行压缩或编码
    * `默认情况下`，通过AMQP发送的消息并不会被压缩
    * 它是一个修饰符，通常用于表明消息体的内容已经使用gzip或者其他形式的压缩方式进行了压缩
    * 形如在电子邮件中，最常见的编码类型是`Base64`和`QuotedPrintable`。`Base64`编码用于确保消息中传输的二进制数据不违反纯文本的`SMTP`协议 【如传图片时，需要将其转为Base64编码】
        * `AMQP是一种二进制协议，这意味着消息体中的内容以原生的状态传输，不在消息编组和解组的过程中进行编码和转换`
* `message-id` 和 `correlation-id` 来唯一标识消息和消息响应，用于实现消息跟踪
    * 这两个是`应用级别`的属性，并没有提供正式的行为定义
        * 允许255个字节的UTF-8编码数据，并以未压缩的方式存储在`Basic.Properties`数据结构中
        * `correlation-id` 用于指定该消息是对另一个消息的响应，通过携带关联消息的`message-id`可以做到这一点
            * 另一种选择是使用它来传递关联消息的事务ID或者其他类似数据
* `timestamp` : 描述消息创建时间
    * 时间戳，一般是一个Unix纪元时间【整数值】
    * `值得注意的是，时间戳没有时区上下文，因此建议在所有消息中使用UTC或其他统一的时区`
        * 当你的消息跨越多个时区到达地理位置分散的RabbitMQ代理服务器时，通过预先对时区进行标准化可以解决可能由此产生的后续问题
* `expiration` : 表明消息过期时间戳
    * 如果指定了该值，那么RabbitMQ将丢弃当前时间大于该值的消息
    * 一般是一个Unix纪元时间戳或整数时间戳
    * RabbitMQ还有可以让消息过期的其他功能，如队列的参数：`x-message-ttl` 
* `delivery-mode` : 将消息写入磁盘或内存队列
    * 一个字节字段，向消息代理服务器表明在将消息投递给任何正在等待的消费者之前，先将它持久化到磁盘上
        * 持久化意味着，即使RabbitMQ服务器重新启动了，消息也会保留到队列中直到被消费
    * `1`: 非持久化消息；`2`: 持久化消息
    * `这个字段的范畴是消息，意味着一个队列可能包含持久化和非持久化的消息`
* `app-id` 和 `user-id` 帮助追踪出现问题的消息发布者应用程序
    * 它们可以用于标识消息源
    * `app-id`
        * 短字符串，最多允许 255个 UTF-8字符
        * 如果你的应用程序采用的是带版本的API为中心的设计，那么在生成消息时可以使用`app-id`传递特定API和版本号
        * 另一个用途是收集统计信息
            * 如果你使用消息来传递登录事件，则可以将app-id属性设置为触发登录事件的平台和应用程序版本
    * `user-id`
        * 在用户身份验证的应用场景中，使用`user-id`属性来标识已登录的用户非常常见
* `type` : 定义发布者和消费者之间的契约
    * 一个自由格式字符串值，通过type属性，你的应用程序可以使用它来确定如何处理一个消息 - 描述消息中的内容
    * ![2-2.jpg](https://littlewulu.cn/source/images/2002/04_TqtKA4jJeW1yfnJhsW8L1tAxmnrZFy.jpg)
    * 另外例如`ETL`(extract-transform-load 提取-转换-加载)过程中，用type来区别一个通用队列中的不同类型的消息
* `reply-to` ： 实现响应消息的路由
    * `reply-to` 属性可以用来携带消费者在回复消息时应该使用的路由键，从而实现RPC模式
* `headers` : 映射表，定义自由格式的属性和实现RabbitMQ路由
    * 一个key-value表，允许用户自定义任意的键和值
        * 键可以是ASCII或Unicode字符串，最大长度255个字符，值可以是任何有效的AMQP值类型
    * 另一个功能是，RabbitMQ可以根据headers表中填充的值路由消息，而不需要依赖路由键 【当交换器类型是`Headers`类型时】
* `priority` : 建议避免使用
    * 用于指定队列中的消息优先级，值范围是 `[0,9]`
        * 值越小，优先级越大
    * AMQP定义明确，但是RabbitMQ并不支持
* `cluster-id` : 已弃用


# 小结

* ![3-3.jpg](https://littlewulu.cn/source/images/2002/04_F2Yz5eI6bjJfkUembPwBFGG15YjY3s.jpg)


